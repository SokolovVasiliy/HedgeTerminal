#property copyright "Copyright 2013, MetaQuotes Software Corp."
#property link      "http://www.mql5.com"
#include <Object.mqh>
#include <Arrays\List.mqh>
#include <Arrays\ArrayObj.mqh>

#include "Log.mqh"

///
/// Идентификатор окна графика на котором запущена панель.
///
#define MAIN_WINDOW 0
///
/// Идентификатор подокна графика, на котором запущена панель.
///
#define MAIN_SUBWINDOW 0

///
/// Определяет к какому углу привязан текущий графический элемент.
///
enum ENUM_TYPE_COORDINATE
{
   ///
   /// Текущий графический элемент привязан к окну отрисовки.
   ///
   COORDINATE_WINDOW,
   ///
   /// Текущий графический элемент привязан к углу своего родительского графического элемента.
   ///
   COORDINATE_PARENT
};

///
/// <b>Универсальный графический узел.</b> Каждый графический элемент, будь то кнопка, текстовая метка или изображение, упаковывается в специальный класс-контейнер GNode.
/// Этот класс-контейнер в свою очередь входит во внутрь такого же класса-родителя. Например кнопка с надписью находящаяся на графической форме образует трехуровневую
/// иерарахию: на самом высоком уровне находится элемент GNode представляющий визуальную форму, внутри него находится такой же элемент представляющий кнопку, а внутри этого
/// элемента будет находится последний графический узел представляющий надпись.
///
class GNode : CObject
{
   public:
      ///
      /// Передвигает текущий графический узел на новые координаты.
      /// \param newXDist - Новое расстояние в пукнтах по вертикали от угла привязки текущего графического элемента. 
      /// \param newYDist - Новое расстояние в пунтках по горизонтали от угла привязки текущего графического элемента. 
      /// \param context - Тип угла привязки текущго графического элемента.
      /// \return Истина, если передвижение прошло удачно, ложь - в противном случае.
      ///
      bool Move(int newXDist, int newYDist, ENUM_TYPE_COORDINATE context);
      ///
      /// Устанавливает новый размер для текущего графического узла.
      /// \param newWidth - новая ширина графического элемента в пунктах.
      /// \param newHigh - новая высота графического элемента в пунктах.
      /// \return Истина, если новый размер графического элемента был удачно установлен, ложь в противном случае.
      bool Resize(int newWidth, int newHigh);
      ///
      /// Устанавливает флаг видимости элемента и всех его подэлементов.
      /// \param isVisible - флаг видимости элемента. Истина, если элемент и все его подэлементы отображается на форме,
      /// ложь - в противном случае.
      ///
      void SetVisible(bool isVisible);
      ///
      /// Возвращает флаг видимости элемента и всех его подэлементов.
      /// \return Истина, если элемент и все его подэлементы видимы, ложь в противном случае.
      ///
      bool GetVisible(void);
      ///
      /// Возвращает расстояние в пунктах по горизонтали от угла привязки текущего графического элемента.
      /// 
      int GetXDistance();
      ///
      /// Возвращает расстояние в пунктах по вертикали от угла привязки текущего графического элемента.
      ///
      int GetYDistance();
      ///
      /// Возвращает ширину в пунктах текущего графического элемента.
      ///
      int GetWidth();
      ///
      /// Возвращает высоту в пунктах текущего графического элемента.
      ///
      int GetHigh();
      ///
      /// Устанавливает угол привязки текущего графического элемента. После вызова функции координаты будут автоматически пересчитанны таким образом, что бы их
      /// значения соответствовали выбранному типу привязки.
      /// \param ctype       - Тип угла, к которому требуется привязать элемент.
      /// \return Истина, если перерасчет координат и смена контекста выполнены успешно и ложь в обратном случае.
      bool SetCoordinatesType(ENUM_TYPE_COORDINATE ctype);
      ///
      /// Инициализирует независимый графический элемент с именем myName (имя может быть не уникальным).
      ///
      GNode(string myName);
      ///
      /// Инициализирует элемент с именем myName (может быть не уникальным) с указанием его родительского графического елемента.
      ///
      GNode(string myName, GNode *pNode);
      ///
      /// Возвращает количество дочерних элементов.
      ///
      int GetChildCount();
   protected:
      ///
      /// Тип объекта, лежащего в основе узла.
      ///
      ENUM_OBJECT ObjectType;
      ///
      /// Имя графического элемента (может повторятся у других графических элементов).
      ///
      string name;
   private:
      ///
      /// Указатель на родительский графический элемент.
      ///
      GNode * parentNode;
      /// <b>Дочерние элементы GNode, распологающиеся внутри текущего графического узла.</b>
      /// Внутри текущего графического узла GNode может находится
      /// неограниченное количество таких же, дочерних визуальных элементов
      /// (MQL5 не поддерживает рекурсивное объявление классов, а
      /// CArrayObj не может работать с потомками CObject, поэтому
      /// используем массив элементов CObject)
      CArrayObj childNodes;
      
      ///
      /// Уникальный идентификатор узла, однозначно определяющий его на графике.
      ///
      string nameId;
      ///
      /// Флаг видимости узла. Истина - если узел отображается на графике, ложь в противном случае.
      ///
      bool visible;
      ///
      /// Идентификатор окна, в котором отображается текущий узел.
      ///
      int chartId;
      ///
      /// Ширина графического узла GNode в пунктах.
      ///
      int width;
      ///
      /// Высота графического узла GNode в пунктах.
      ///
      int high;
      ///
      /// Дистанция в пунктах по горизонтали от угла привязки текущего графического элемента.
      ///
      int xDistance;
      ///
      /// Дистанция в пунктах по вертикали от угла привязки текущего графического элемента.
      ///
      int yDistance;
      ///
      /// Определяет к какому углу привязан текущий графический элемент. Дистанция по горизонтали и вертикале автоматически
      /// перерасчитывается в зависимости от типа привязки.
      ///
      ENUM_TYPE_COORDINATE typeCoordinate;
      ///
      /// Инициализирует графический элемент
      ///
      void Init(string myName, GNode* pNode);
      ///
      /// Генерирует уникальное имя элемента, с помощью которого можно однозначно идентифицировать
      /// элемент на графике терминала.
      ///
      void GenNameId(void);
      
};
GNode::GNode(string myName)
{
   Init(myName, NULL);
}

GNode::GNode(string myName, GNode *pNode)
{
   Init(myName, pNode);
}
void GNode::Init(string myName, GNode *pNode)
{
   name = myName;
   parentNode = pNode;
   visible = false;
   xDistance = 0;
   yDistance = 0;
   typeCoordinate = COORDINATE_PARENT;
   GenNameId();
}

bool GNode::Resize(int newWidth, int newHigh)
{
   width = newWidth;
   high = newHigh;
   return true;
}

void GNode::SetVisible(bool isVisible)
{
   //Отображаем текущий элемент
   if(isVisible && !visible)
   {
      visible = ObjectCreate(MAIN_WINDOW, nameId, ObjectType, MAIN_SUBWINDOW, xDistance, yDistance);
      ObjectSetInteger(MAIN_WINDOW, nameId, OBJPROP_XSIZE, width);
      ObjectSetInteger(MAIN_WINDOW, nameId, OBJPROP_YSIZE, high);
      //Все подэлементы текущего элемента также автоматически становятся видимы:
      GNode *p = NULL;
      for(int i = 0; i < childNodes.Total(); i++)
      {
         p = childNodes.At(i);
         p.SetVisible(true);
      }
   }
   else if(!isVisible && visible)
   {
      //Все подэлементы текущего элемента также автоматически становятся невидимы:
      GNode *p = NULL;
      bool res = true;
      for(int i = 0; i < childNodes.Total(); i++)
      {
         p = childNodes.At(i);
         p.SetVisible(false);
      }
      visible = !ObjectDelete(0, nameId);
   }
}

void GNode::GenNameId(void)
{
   //Получаем имя с указанием его порядкового номера
   int index = GetChildCount();
   //Если объект с таким именем уже существует
   //добавляем к имени индекс, до тех пор пока имя не станет уникальным.
   int res = -1;
   while(res > 0)
      res = ObjectFind(0, name + (string)index++);
   nameId = name+(string)index;
}

int GNode::GetChildCount()
{
   if(CheckPointer(parentNode) == POINTER_INVALID)
      return 0;
   else
      return parentNode.GetChildCount();
}
